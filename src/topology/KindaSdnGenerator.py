from core.K8sNode import K8sNode
from topology.Node import NodeConfig, NodeMeta, NodeType, PeerNameToIpMac
from util.codegen import CodeGenHelper

_external_device_template = \
    '''{var} := &model.ExternalDevice{{
        BaseDevice: model.BaseDevice{{
            Name: "{name}",
            Links: []*model.Link{{
{links}
            }},
        }},
    }}'''

_inc_switch_template = \
    '''{var} := model.NewBmv2IncSwitch(
        "{name}", 
        []*model.Link{{
{links}
        }},
        "{ip}:{port}",
    )'''

_host_template = \
    '''{var} := &model.Host{{
        BaseDevice: model.BaseDevice{{
            Name: "{name}",
            Links: []*model.Link{{
{links}
            }},
        }},	
    }}'''

_topology_func_template = \
    '''func {func_name}() *model.Topology {{
{vars_code}
    return &model.Topology{{
        Devices: []model.Device{{
{vars}
        }},
    }}
}}'''

_topology_file_template = \
    '''// Code generated by kinda-p4. DO NOT EDIT.

package generated

import "github.com/Fl0k3n/k8s-inc/kinda-sdn/model"

{topology_func}
'''


class KindaSdnTopologyGenerator:

    class TopologyFunctionBuilder:
        def __init__(self, function_name: str) -> None:
            self.function_name = function_name
            self.devices: list[NodeConfig] = []

        def _build_external_device(self, var: str, name: str, links: str) -> str:
            return _external_device_template.format(var=var, name=name, links=links)

        def _build_inc_switch(self, var: str, name: str, links: str, grpc_port: int) -> str:
            return _inc_switch_template.format(var=var, name=name, links=links, ip="127.0.0.1", port=str(grpc_port))

        def _build_host(self, var: str, name: str, links: str) -> str:
            return _host_template.format(var=var, name=name, links=links)

        def build(self) -> str:
            code = CodeGenHelper()
            vars = []
            for i, (name, dev, links) in enumerate(self.devices):
                var_name = f'dev{i}'
                vars.append(var_name)
                links_code_gen = CodeGenHelper()
                for (peer_name, ip, mac) in links:
                    ip, mask = ip.split('/')
                    links_code_gen.append(
                        f'model.NewLink("{peer_name}", "{mac}", "{ip}", {mask}),')
                if dev.get_type() == NodeType.EXTERNAL:
                    code.append(self._build_external_device(
                        var_name, name, links_code_gen.join_indented(4)))
                elif dev.get_type() == NodeType.HOST or dev.get_type() == NodeType.K8S:
                    code.append(self._build_host(var_name, name,
                                links_code_gen.join_indented(4)))
                elif dev.get_type() == NodeType.INC_SWITCH:
                    meta = dev.inc_switch_meta()
                    assert meta.grpc_port is not None
                    code.append(self._build_inc_switch(
                        var_name, name, links_code_gen.join_indented(3), meta.grpc_port))
                else:
                    raise Exception("Unexpected device")
            vars_gen = CodeGenHelper()
            vars_gen.append(", ".join(vars) + ",")
            return _topology_func_template.format(
                func_name=self.function_name,
                vars_code=code.join_indented(1),
                vars=vars_gen.join_indented(3)
            )

        def with_node(self, node_config: NodeConfig) -> "KindaSdnTopologyGenerator.TopologyFunctionBuilder":
            self.devices.append(node_config)
            return self

    def _build_topology_func(self, funcname: str, node_configs: list[NodeConfig]) -> str:
        builder = self.TopologyFunctionBuilder(funcname)
        for node in node_configs:
            builder.with_node(node)
        return builder.build()

    def _replace_k8s_names_with_cluster_internal(self, node_configs: list[NodeConfig], k8s_nodes: dict[str, K8sNode]) -> list[NodeConfig]:
        res = []
        for nc in node_configs:
            links = []
            for link in nc.links:
                if link.peer_name in k8s_nodes:
                    links.append(link._replace(
                        peer_name=k8s_nodes[link.peer_name].internal_node_name))
                else:
                    links.append(link)
            new_name = k8s_nodes[nc.name].internal_node_name if nc.name in k8s_nodes else nc.name
            res.append(nc._replace(name=new_name, links=links))
        return res

    def write_topology_file(self, funcname: str, k8s_nodes: dict[str, K8sNode], node_configs: list[NodeConfig], path: str):
        node_configs = self._replace_k8s_names_with_cluster_internal(
            node_configs, k8s_nodes)
        func_code = self._build_topology_func(funcname, node_configs)
        file_content = _topology_file_template.format(topology_func=func_code)
        with open(path, 'w') as f:
            f.write(file_content)
